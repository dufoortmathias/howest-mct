\documentclass{article}

\usepackage[english]{babel}
\usepackage[margin=3cm]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage[parfill]{parskip}

% fonts
\usepackage[T1]{fontenc}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

\graphicspath{{img/}}
 
\newcommand{\bold}[1]{\textbf{#1}}

%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{upquote}
\usepackage{color} %use color
\usepackage{xcolor}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%Define csharp
\lstdefinelanguage{csharp}{language=[Sharp]C, frame=lrtb, rulecolor=\color{blue!80!black}}

\begin{document}

\begin{titlepage}
    \author{Tuur Vanhoutte}
    \title{Device Programming}
\end{titlepage}

\pagenumbering{gobble}
\maketitle
\newpage
\tableofcontents
\newpage

\pagenumbering{arabic}

\section{.NET}

.NET is a free, cross-platform, open source developer platform (*) for building many different types of applications.

* languages + libraries

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{net-ecosystem.png}
    \caption{.NET ecosystem}
\end{figure}

\subsection{Languages}

\begin{itemize}
    \item Syntax very similar to C, C++, Java \& JavaScript
    \item Functional programming language, cross-platform, open source
    \item Approachable English-like language for OOP
\end{itemize}

\subsection{Applications}

\begin{itemize}
    \item desktop
    \item web \& server
    \item mobile
    \item gaming
    \item IoT
    \item AI
\end{itemize}

\subsubsection{Desktop}

\begin{itemize}
    \item UWP (Universal Windows Project)
    \item Xamarin.Mac
    \item WPF (Windows Presentation Foundation)
    \item WinForms (Windows Forms)
\end{itemize}

\subsubsection{Web \& Server}
\begin{itemize}
    \item ASP.NET
    \item ASP.NET Core
\end{itemize}

\subsubsection{Mobile}
\begin{itemize}
    \item UWP (Universal Windows Project)
    \item Xamarin
\end{itemize}

\subsubsection{Gaming}
\begin{itemize}
    \item Unity
    \item CryEngine
\end{itemize}

\subsubsection{IoT}
\begin{itemize}
    \item UWP
    \item .NET Core IoT
\end{itemize}

\subsubsection{AI}

\begin{itemize}
    \item Cognitive Services
    \item Azure Machine Learning
    \item Machine Learning and AI Libraries
    \item F\# for Data Science and ML
\end{itemize}

\subsection{Xamarin}
\begin{itemize}
    \item `Target all platforms with a single, shared codebase for Android, iOS, Windows'. 
    \item Developen van Mobile devices lastig: verschillende platformen, verschillende talen voor elk device.
    \item Oplossing: Xamarin
    \item Extensie op Visual Studio.
\end{itemize}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.1\textwidth]{xamarin-logo.png}
    \caption{Xamarin Logo}
\end{figure}

\subsubsection{Xamarin - UI Technology}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{xamarin-forms.png}
    \caption{Native vs Xamarin.Forms}
\end{figure}

\subsubsection{Xamarin - Code Sharing strategy}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{xamarin-codesharing.png}
    \caption{.NET Standard vs Shared (Assets) Project}
\end{figure}

Met Shared Assets Project maken we de UI voor elk platform apart. Wij gaan vooral werken met .NET Standard.


\subsection{Summary}

\begin{itemize}
    \item What devices, platforms, etc. can we target using .NET, and what programming languages can we use?
    \item What is the basic difference between .NET Standard and Shared Assets projects in Xamarin?
    \item What is the difference between Xamarin native and Xamarin.Forms? What are the advantages and disadvantages?
    \item How to set up and understand the structure of a Xamarin project for the labs in this course, and how to debug on the different platforms.
\end{itemize}

\section{C\# Syntax}

\subsection{Python vs C\#}

\begin{itemize}
    \item curly brackets \{ \} in plaats van indenting
\end{itemize}

\subsection{Datatypes}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{csharp-datatypes.png}
    \caption{Datatypes in C\#}
\end{figure}

\subsection{Collections}
\begin{itemize}
    \item Array
    \item Dictionary<TKey, TValue>
    \item List<T>
\end{itemize}

Collection type = fixed! $\Rightarrow$ Je kan alleen objecten van het gekozen type toevoegen aan een collection

\begin{lstlisting}[language=csharp]
//collections of type Person:
Person[] teacherArr = new Person[10];
List<Person> teacherList = new List<Person>();

//You can only add Person objects to these collections!
\end{lstlisting}


\subsubsection{Arrays}
= meerdere variabelen van hetzelfde type

\begin{lstlisting}[language=csharp]
//initialize int array with 10 positions:
int[] numbers = new int[10];
//save number 13 in the first position
numbers[0] = 13;
//print the value of the first number in the array:
Debug.WriteLine("The first number is:" +numbers[0]);
//intialize and fill another array with 4 numbers:
int[] startPositions = { 4, 1, 9, 3 };
\end{lstlisting}

\subsubsection{Dictionary <TKey, TValue>}

\begin{lstlisting}[language=csharp]
//declare dictionary with key type & value type
Dictionary<string, int> studentScores = new Dictionary<string, int>();
//add two elements (key value pairs)
studentScores.Add("Jean-Jacques", 13);
studentScores.Add("Jean-Louis", 4);
//get the score of Jean-Jacques
int score = studentScores["Jean-Jacques"];
\end{lstlisting}


\subsubsection{List<T>}

\begin{lstlisting}[language=csharp]
//declare list, fill one by one:
List<string> emailList = new List<string>();
emailList.Add("stijn.walcarius@howest.be");
emailList.Add("frederik.waeyaert@howest.be");
//get elements out (two ways):
string first = emailList.ElementAt(0);
string second = emailList[1];
//declare + fill list:
List<string> teacherList = new List<string> { "SWC", "FWA" };
\end{lstlisting}

\subsection{Selections}
if / else if / else / switch

\begin{lstlisting}[language=csharp]
if(findTheoryTeacher == true) {
    email1 = "frederik.waeyaert@howest.be";
    email2 = null;
}
else if(findLabTeachers == true) {
    email1 = "stijn.walcarius@howest.be";
    email2 = " frederik.waeyaert@howest.be";
} else {
    email1 = email2 = null;
}
\end{lstlisting}

\begin{lstlisting}[language=csharp]
switch (teacher){
    case "SWC":
        email = "stijn.walcarius@howest.be";
        break;
    case "FWA":
        email = "frederik.waeyaert@howest.be";
        break;
    default:
        email = "info@howest.be";
        break;
}
\end{lstlisting}

\subsection{Loops}
for / foreach / while / do while

\begin{lstlisting}[language=csharp]
for(int i = 0; i < 100; i++) {
    //do something 100 times
}
\end{lstlisting}

\begin{lstlisting}[language=csharp]
List<string> teacherList = new List<string> { "SWC", "FWA" };
foreach(string teacher in teacherList) {
    //do something
}
\end{lstlisting}

\begin{lstlisting}[language=csharp]
while(endOfClass == false){
    //might never be executed
}
\end{lstlisting}

\begin{lstlisting}[language=csharp]
do {
    //executed at least once!
} while(endOfClass == false);
\end{lstlisting}

\subsection{Classes}
\begin{lstlisting}[language=csharp]
public class Person
{
    //property
    public string Name { 
        get {...};
        set {...}; 
    }

    //constructor
    public Person(string name) {
        this.Name = name;
    }

    //method
    public void Subscribe() {
        //do something
    }
}
\end{lstlisting}

\subsection{Instantiate objects}

\begin{lstlisting}[language=csharp]
Persons p1 = new Person("Stijn");

// Based on the following constructor in the Person class:
public Person (string name) {
    this.Name = name;
}
\end{lstlisting}

\subsection{Properties}

\subsubsection{Fields vs properties}

\begin{itemize}
    \item Fields store the actual data
    \item Properties are used to access those fields
    \item Auto-implemented properties have a hidden field
    \item Use properties to control field access
    \item Enhance input/output control using get \& set
    \item Calculated properties build on other properties
    \begin{itemize}
        \item No field required
        \item Reusability
    \end{itemize}
\end{itemize}

\begin{lstlisting}[language=csharp]
//private field
private int _id;

//property (zetten we altijd public)
public int Id {
    // getter
    get { return _id; }
    // setter
    set { _id = value; }
}
\end{lstlisting}


\subsubsection{Default values for properties}

\begin{itemize}
    \item Setting default values can be useful
    \item Default values can be set\dots
    \begin{itemize}
        \item \dots with full properties
        \item \dots with auto-implemented properties
        \item \dots in the constructor
    \end{itemize}
\end{itemize}

\subsection{Constructor}

\begin{itemize}
    \item A constructor is called every time you create an instance of a class
    \item It is used to allow / force the user to provide certain values
    \item Default constructor is (only) added if a model has no constructors
    \item Constructor overloading = multiple constructors with either \dots
    \begin{itemize}
        \item \dots a different number of parameters, or
        \item \dots a different type of paramters, or
        \item \dots the same parameters in a different order
    \end{itemize}
    \item Constructors should call each other for enhanced efficiency
    \item Constructors in inheriting classes call the constructors of the base class
\end{itemize}


\section{Streamreader}

\begin{itemize}
    \item Namespaces
    \item System.Reflection
    \item Embedded Files
    \item System.IO
\end{itemize}

\subsection{Namespaces}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{namespaces.png}
    \caption{Namespaces}
\end{figure}

\subsection{System.Reflection}

\textit{"The classes in the System.Reflection namespace, together with
System.Type, enable you to obtain information about loaded
assemblies and the types defined within, such as classes, interfaces,
and value types. You can also use \bold{reflection} to create type instances
at run time and to invoke them."}


\subsection{System.IO}

= Input/Output \url{https://developer.xamarin.com/api/namespace/System.IO/}

\begin{itemize}
    \item StreamReader \url{https://developer.xamarin.com/api/type/System.IO.StreamReader/}
    \item StreamWriter \url{https://developer.xamarin.com/api/type/System.IO.StreamWriter/}
\end{itemize}

\subsection{Embedded files}

\begin{itemize}
    \item Textfiles, images, etc.
    \item Generates a \bold{ResourceID} for the file
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{embedded-files0.png}
    \caption{Embedded files inladen in een Visual Studio project: rechtermuisknop op 1 of meerdere files $\Rightarrow$ properties $\Rightarrow$ build action = Embedded resources}
\end{figure}

\subsubsection{Read an embedded file in Xamarin}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{embedded-files.png}
    \caption{}
\end{figure}

\begin{itemize}
    \item 
\end{itemize}

\subsubsection{Processing the file's content}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{embedded-files2.png}
    \caption{}
\end{figure}

\subsection{Summary}

\begin{itemize}
    \item You understand the importance of \bold{namespaces}, and the techniques of using them in your own projects.
    \item You can explain the very basics of the \bold{System.IO} and \bold{System.Reflection} namespaces, and what they have to do with reading an embedded file in Xamarin.
    \item You understand the how and why of the \bold{ResourceID} thatâ€™s being generated for an embedded file.
\end{itemize}

\section{Navigation}

\subsection{Modal vs Modeless}

\begin{itemize}
    \item Modal page: requires user input to continue
    \item Modeless page: user can go back any time he wants; no input required
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{modal-page.png}
    \includegraphics[width=0.4\textwidth]{modeless-page.png}
    \caption{Modal page vs Modeless page}
\end{figure}

\subsection{Navigate forward}

\begin{lstlisting}[language=csharp]
Navigation.PushAsync(new FooPage());
Navigation.PushModalAsync(new FooPage());

// FooPage is hier de XAML page waar we willen naar navigeren
\end{lstlisting}

\begin{itemize}
    \item PushAsync vs PushModalAsync
    \item Navigation object: controls the navigation stack
\end{itemize}

\subsection{Navigate back}

\subsubsection{Go back - Modeless page}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{navigation-back-modeless.png}
    \caption{}
\end{figure}

\subsubsection{Go back - Modal page}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{navigation-back-modal.png}
    \caption{}
\end{figure}

\subsection{Navigation stack}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{navigation-stack-1.png}
    \caption{Pushen op de stack}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{navigation-stack-2.png}
    \caption{Pop'en van de stack}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{navigation-stack-3.png}
    \caption{InsertPageBefore}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{navigation-stack-4.png}
    \caption{RemovePage}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{navigation-stack-4.png}
    \caption{PopToRoot}
\end{figure}

\subsection{Page types}

\begin{itemize}
    \item ContentPage
    \item MasterDetailPage (zie Demo\_MasterDetail)
    \item NavigationPage (zie Demo\_Navigation)
    \item TabbedPage (zie Demo\_TabbedPage)
    \item TemplatedPage
    \item CarouselPage 
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{pagetypes.png}
    \caption{}
\end{figure}

\subsection{Exchanging data}

How to exchange data between several pages:

\begin{enumerate}
    \item Constructor (Demo\_MasterDetail)
    \item Properties (Demo\_TabbedPage)
\end{enumerate}

\subsection{Summary}

\begin{itemize}
    \item The different \bold{page types} and how to use them.
    \item The difference between \bold{Modal} and \bold{Modeless} pages, and how to manage navigation for both.
    \item You know how to \bold{exchange data} between pages in the navigation process.
    \item You understand the \bold{navigation stack} and how you can manipulate it.
    \item You can explain the concept of a \bold{master-detail} relation with an example
\end{itemize}

\section{Object Orientation}

\subsection{Inheritance}

= klasses nemen methods en properties over van een andere klasse. 

Er ontstaat een hi"erarchie.

\begin{lstlisting}[language=csharp]
// the base class: 

public class Advisor
{
    // properties
    public string Name { get; set; }

    // methods
    public void Advise() { }
}

// the deriving class
// notice the : between the base class and deriving class

public class MinisterOfDefense : Adviser {
    // code here
}

\end{lstlisting}

\begin{itemize}
    \item All C\# classes, of any type, are treated as if they ultimately derive from System.Object
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{inheritance.png}
    \caption{}
\end{figure}

\begin{itemize}
    \item \bold{Generalize} properties (equal for all) by putting them in the \bold{base class}
    \item \bold{Specify} properties (specific for one) by putting them in the \bold{deriving class}
\end{itemize}

\subsubsection{Constructor}

\begin{itemize}
    \item Constructors are \bold{not} inherited!
    \item Constructor without parameter in base class?
    \begin{itemize}
        \item $\Rightarrow$ Automatically called by deriving class
    \end{itemize}
    \item No constructor without parameters in base class?
    \begin{itemize}
        \item $\Rightarrow$ Explicitly call it in deriving classes
    \end{itemize}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{inheritance-constructor.png}
    \caption{Inheritance: constructor example}
\end{figure}

\subsubsection{Access modifiers}

public is the default access modifier.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{inheritance-access-modifiers.png}
    \caption{Inheritance: access modifiers}
\end{figure}

\subsubsection{Properties/methods: VIRTUAL and OVERRIDE}

When you want to override a method from the base class, 
use the virtual keyword in the base method,
and the override method in the derived method.

Virtual properties/methods:
\begin{itemize}
    \item Default implementation in base class
    \item `virtual' keyword, to \bold{replace} the way an object behaves
    \item \bold{CAN} be overriden in subclasses, only if necessary.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{inheritance-override.png}
    \caption{}
\end{figure}


\subsubsection{Properties/methods: ABSTRACT and OVERRIDE}

Abstract properties/methods:

\begin{itemize}
    \item No default implementation possible in base class
    \item `abstract' keyword, to \bold{extend} the way an object behaves
    \item \bold{MUST} be present in each deriving class
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{inheritance-abstract.png}
    \includegraphics[width=0.4\textwidth]{inheritance-abstract2.png}
    \caption{}
\end{figure}


\subsection{Polymorphisme}

= Objects of a derived class can be treated like objects of the base class at runtime

\bold{Example:} say we have a class Animal, and two classes Cat and Dog that inherit the Animal class.
Then, this is possible: 

\begin{lstlisting}[language=csharp]
List<Animal> animals = new List<Animal>();
Animal dog = new Dog();
Animal cat = new Cat();

animals.Add(dog);
animals.Add(cat);
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{polymorphism.png}
    \caption{Polymorphism example}
\end{figure}

\subsubsection{Disadvantage}

\textcolor{red}{!!!} \bold{Multiple inheritance} is \bold{NOT} allowed through classes in C\# \textcolor{red}{!!!}

\subsection{Interfaces}

\begin{itemize}
    \item Interfaces can be seen as contracts for classes
    \item Implementing = applying the contract
    \item An interface \bold{forces} all implementing classes to implement all properties and/or methods
    \item An interface has no default implementation on its own (=you can't create an instance from an interface)
\end{itemize}

\subsubsection{Summary}

\begin{itemize}
    \item Contract + NO implementations = interface
    \item Contract + SOME implementations = abstract (base) class
    \item Implementation for all properties \& methods = normal (base) class
\end{itemize}

\subsubsection{Example}

\begin{itemize}
    \item The IAdvisor interface has an Advice() method (notice that method has no default implementation)
    \item Every class that implements this interface also must have its own Advice() method
    \item A class can implement multiple interfaces (see the MicrosoftCEO class)
    \item In the PrimeMinister class:
    \begin{itemize}
        \item A list is created with the same type as the interface
        \item Every element in that list is of a class that implements the interface
        \item Can therefore also be used in a foreach() loop
    \end{itemize}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{interfaces.png}
    \caption{Interfaces example}
\end{figure}

\subsection{Composition}

= Creating an instance of an object from a class in another class.

\subsubsection{Example}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{composition1.png}
    \caption{How can we make an instance of `\_disk'?}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{composition2.png}
    \caption{Solution: 3 options}
\end{figure}

\bold{Option 1:} creating it at the start of the class (=composition)

\bold{Option 2:} using the constructor (=composition)

\bold{Option 3:} Outside of the class, by creating a new object an assigning that object to the `\_disk' property in the class.

The 3rd option is called \bold{Aggregation}. Unlike the other options, the `myDisk' object keeps existing even if the PC class stops existing.

\subsubsection{Interfaces in Xamarin(.Forms)}

Interfaces in Xamarin(.Forms) is extremely useful: 

Say you need to get data from a specific sensor on your Android/iOS/UWP device. 
We can create an interface in our project, and implement that interface in each device's code.
Once we need to get that data, we can automatically call the correct method for the correct device,
by just calling the interface's method.

\subsection{Summary}

\begin{itemize}
    \item You are convinced by the advantages of \bold{inheritance} and \bold{polymorphism}, and can explain using an example
    \item  You understand the usage and consequences of the \bold{virtual} and \bold{abstract} keywords for properties and methods.
    \item  You know when to use \bold{abstract classes} and/or \bold{interfaces}, and can explain the difference between those two.
    \item  You understand the specific importance of interfaces in \bold{Xamarin}(.Forms)
\end{itemize}

\end{document}